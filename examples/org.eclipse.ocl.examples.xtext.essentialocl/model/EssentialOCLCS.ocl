import 'EssentialOCLCS.ecore'
import '/resource/org.eclipse.ocl.examples.pivot/model/Pivot.ecore'

import '/resource/org.eclipse.ocl.examples.xtext.base/model/BaseCS.ocl' -- To import other OCL definitions

package essentialoclcs

--context AbstractNameExpCS
--def : ast() : ocl::Element
--
--		/*
--		 * For explicit source invocations, sourceType provides the true source type after resolution of implicit set or implicit collect.
--		 */
--		property sourceType : ocl::Type[?] { derived transient !resolve };
--	}


-- context BinaryOperatorCS

context BooleanLiteralExpCS
def : ast() : ocl::BooleanLiteralExp = 
	ocl::BooleanLiteralExp {
		booleanSymbol =	if name = 'true' 
						then true
						else false
						endif,
		type = Boolean
	}
	
context CollectionLiteralExpCS 
def : ast() : ocl::CollectionLiteralExp =
	ocl::CollectionLiteralExp {
		kind = ocl::CollectionKind.allInstances()->any(name=ownedType.name),
		part = ownedParts.ast(),
		type = ownedType.ast()
	}

context CollectionLiteralPartCS
def : ast() : ocl::CollectionLiteralPart = 
	if lastExpressionCS = null
	then ocl::CollectionItem {
			item = expressionCS.ast()	
		}
	else ocl::CollectionRange {
			first = expressionCS.ast(),
			last = lastExpressionCS.ast()
		}
	endif

context CollectionTypeCS
def : ast() : ocl::CollectionType =
	 -- env().lookupCollectionType(name, ownedType)
	let lower : Integer = 
			if multiplicity = null
			then null
			else multiplicity.getLower()
			endif,
		upper : UnlimitedNatural =
			if multiplicity = null
			then null
			else 
				if multiplicity.getUpper() = -1
				then *
				else multiplicity.getUpper()
				endif
			endif
	in	ocl::CollectionType {
			name = name,
			elementType = ownedType.ast(),
			lower = lower,
			upper = upper
		}

context ConstructorExpCS
def : ast() : ocl::ConstructorExp =
	ocl::ConstructorExp {
		value = value,
		part = ownedParts.ast(),
		type = env().lookupType(nameExp.pathName)
	}
--inv : ownedParts->notEmpty() implies value = null
--		and not (value = null) implies ownedParts->isEmpty()
	
context ConstructorPartCS
def : ast() :  ocl::ConstructorPart =
	ocl::ConstructorPart {
		initExpression = initExpression.ast(),
		referredProperty = property -- TODO
	}
	
context ContextCS
def : ast() : ocl::ExpressionInOCL = 
	ocl::ExpressionInOCL {
		bodyExpression = ownedExpression.ast()
	}

-- context ExpCS 

context ExpSpecificationCS
def : ast() : ocl::ExpressionInOCL =
	ocl::ExpressionInOCL {
		language = 'OCL',
		_body = if exprString = null
				then null
				else  Sequence(String){exprString}
				endif,
		expressionInOCL = 
				if ownedExpression = null
				then null 
				else ownedExpression.ast()
				endif
	}
context IfExpCS
def : ast() : ocl::IfExp =
	ocl::IfExp {
		condition = condition.ast(),
		thenExpression = thenExpression.ast(),
		elseExpression = elseExpression.ast()
	}
	
-- TODO	No idea what is this. Nothing in the spec
-- context IndexExpCS

context InfixExpCS
def : ast() : ocl::OperationCallExp = 
	let first : ExpCS = ownedExpression->first(),
		others : Sequence(ExpCS) = ownedExpression->excluding(first)
	in  others->iterate(x : ExpCS; result : ocl::OperationCallExp = null |
					if result = null
					then result = ocl::OperationCallExp {
						name = ownedOperator->at(others->indexOf(x)),
						source = first.ast(),
						argument = Sequence(ocl::OperationCallExp) {x.ast()}
						-- TODO referred operation = name resolution
					}
					else result = ocl::OperationCallExp {
						name = ownedOperator->at(others->indexOf(x)),
						source = result,
						argument = Sequence(ocl::OperationCallExp) {x.ast()}
						-- TODO referredOperation = name resolution
					}
					endif)
	
context InvalidLiteralExpCS
def : ast() : ocl::InvalidLiteralExp = 
	ocl::InvalidLiteralExp {
		type = OclInvalid
	}

-- TODO context InvocationExpCS

context LetExpCS
def : ast() : ocl::LetExp = 
	variable->reverse()->iterate(x : LetVariableCS; result : ocl::LetExp = null |
				if result = null
				then result = ocl::LetExp {
						variable = x.VariableCS::ast(),
						_'in' = _'in'.ast()
					}
				else result = ocl::LetExp {
						variable = x.VariableCS::ast(),
						_'in' = result
					}	
				endif
			)

-- context LetVariableCS
-- note: VariableCS::ast() operation works for LetVariableCS
	
context	NameExpCS
def : ast() : ocl::Element =
	env().lookupPathName(pathName)
	-- FIXME where is the xtext AS cross-reference ? sourceType ?
	
-- TODO context NavigatingArgCS 


-- TODO context NavigationOperatorCS

-- TODO context NestedExpCS

context NullLiteralExpCS
def : ast() : ocl::NullLiteralExp = 
	ocl::NullLiteralExp {
		type = OclVoid
	}
	
context NumberLiteralExpCS
def : ast() : ocl::NumericLiteralExp =
	ocl::IntegerLiteralExp {
		integerSymbol = name -- FIXME Integer/Real/
	}
	
context PrefixExpCS
def : ast() : ocl::OperationCallExp = 
	ownedOperator->reverse()->iterate(x : UnaryOperatorCS; result : ocl::OperationCallExp = null |
					if result = null
					then result = ocl::OperationCallExp {
							name = x.name,
							source = ownedExpression.ast()
							-- referredOperation = name resolution
						}
					else result = ocl::OperationCallExp {
							name = x.name,
							source = result
							-- referredOperation = name resolution
						}
					endif)

-- context PrimitiveLiteralExpCS 

context SelfExpCS
def :  ast() : ocl::VariableExp = 
	let refVariable : ocl::VariableDeclaration = env().lookupVariableDeclaration(name)
	in ocl::VariableExp {
			referredVariable = refVariable, 
			type = refVariable.type 
	}
		
context StringLiteralExpCS
def : ast() : ocl::StringLiteralExp = 
	ocl::StringLiteralExp {
		stringSymbol = name,
		type = String
	}
	
context TupleLiteralExpCS
def : ast() : ocl::TupleLiteralExp = 
	ocl::TupleLiteralExp {
		part = ownedParts.ast()
		-- type = env().lookupTuple(ownedParts)
	}

context TupleLiteralPartCS
def : ast() : ocl::TupleLiteralPart = 
	ocl::TupleLiteralPart {
		name = name,
		initExpression = initExpression,
		type = ownedType.ast()
	}
	
context TypeLiteralExpCS
def : ast() : ocl::TypeExp = 
	let refType : ocl::Type = ownedType.ast()
	in ocl::TypeExp {
			referredType = refType,
			type = refType
	}

context TypeNameExpCS
def : ast() : ocl::Type =
	element
	
-- TODO context UnaryOperatorCS
context UnlimitedNaturalLiteralExpCS
def : ast() : ocl::UnlimitedNaturalLiteralExp =
	ocl::UnlimitedNaturalLiteralExp{
		unlimitedNaturalSymbol = ocl::_UnlimitedNatural{'-1'}
	}

context VariableCS
def : ast() : ocl::Variable = 
	ocl::Variable {
		name = name,
		initExpression = initExpression.ast(),
		type = ownedType.ast()
	}
endpackage
