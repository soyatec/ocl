import basecs : '../../org.eclipse.ocl.examples.xtext.base/model/BaseCS.oclinecore';
import ecore : 'http://www.eclipse.org/emf/2002/Ecore';

package essentialoclcs : essentialoclcs = 'http://www.eclipse.org/ocl/3.1.0/EssentialOCLCST'
{
	abstract class AbstractNameExpCS extends ExpCS { interface }
	{
		operation getNamedElement() : ocl::NamedElement[?];
		operation getNameExp() : AbstractNameExpCS;
		operation getPathName() : basecs::basecs::PathNameCS[?];

		/*
		 * For explicit source invocations, sourceType provides the true source type after resolution of implicit set or implicit collect.
		 */
		property sourceType : ocl::Type[?] { derived transient !resolve };
	}
	class BinaryOperatorCS extends OperatorCS
	{
		property argument : ExpCS { transient !resolve };
	}
	class BooleanLiteralExpCS extends PrimitiveLiteralExpCS
	{
		operation ast() : ocl::BooleanLiteralExp
		{
			body: ocl::BooleanLiteralExp {
				booleanSymbol = if name = 'true' 
							    then true
							    else false
							    endif,
				type = Boolean
			};
		}
		attribute name : String[?];
	}
	class CollectionLiteralExpCS extends LiteralExpCS
	{
		operation ast() : ocl::CollectionLiteralExp
		{
			body: ocl::CollectionLiteralExp {
				kind = ocl::CollectionKind.allInstances()->any(name=ownedType.name),
				part = ownedParts.ast(),
				type = ownedType.ast()
				};
		}
		property ownedType : CollectionTypeCS[?] { composes };
		property ownedParts : CollectionLiteralPartCS[*] { ordered composes };
	}
	class CollectionLiteralPartCS extends basecs::basecs::ModelElementCS
	{
		operation ast() : ocl::CollectionLiteralPart
		{
			body: 	if lastExpressionCS.oclIsUndefined() 
					then ocl::CollectionItem {
							item = expressionCS.ast()	
						}
					else ocl::CollectionRange {
							first = expressionCS.ast(),
							last = lastExpressionCS.ast()
						}
					endif;
		}
		property expressionCS : ExpCS[?] { composes };
		property lastExpressionCS : ExpCS[?] { composes };
	}
	class CollectionTypeCS extends basecs::basecs::TypedRefCS,ocl::Nameable
	{
		operation ast() : ocl::CollectionType
		{
			body: env().lookupCollectionType(name, ownedType);
		}
		attribute name : String[?];
		property ownedType : basecs::basecs::TypedRefCS[?] { composes };
	}
	class ConstructorExpCS extends NamedExpCS
	{
		operation ast() : ocl::ConstructorExp
		{
			body: 	ocl::ConstructorExp {
						value = value,
						part = ownedParts.ast(),
						type = env().lookupType(nameExp.pathName)
					};
		}
		property ownedParts : ConstructorPartCS[*] { ordered composes };
		attribute value : String[?];
		invariant : ownedParts->notEmpty() implies value->oclIsUndefined()
					and not value->oclIsUndefined() implies ownedParts->isEmpty();
	}
	class ConstructorPartCS extends basecs::basecs::ModelElementCS,ocl::Nameable
	{
		operation ast() : ocl::ConstructorPart
		{
			body: 	ocl::ConstructorPart {
						initExpression = initExpression.ast(),
						referredProperty = _property
					};
		}
		property property : ocl::Property;
		property initExpression : ExpCS { composes };
	}
	class ContextCS extends basecs::basecs::NamedElementCS,basecs::basecs::RootCS
	{
		operation ast() : ocl::ExpressionInOCL
		{
			body: ocl::ExpressionInOCL {
				bodyExpression = ownedExpression.ast()
			};
		}
		property ownedExpression : ExpCS[?] { composes };
	}
	class ExpCS extends basecs::basecs::ModelElementCS
	{

		/*
		 * abstract
		 */
		operation ast() : ocl::OCLExpression;
		property parent : OperatorCS[?] { transient !resolve };
		attribute hasError : Boolean[?] = 'false' { transient };
	}
	class ExpSpecificationCS extends basecs::basecs::SpecificationCS
	{
		/*
		 * FIXME no idea
		 */
		operation ast() : ocl::ExpressionInOCL
		{
			body: ocl::ExpressionInOCL {
				bodyExpression = ownedExpression.ast()
			};
		}
		property ownedExpression : ExpCS[?] { composes !resolve };
	}
	class IfExpCS extends ExpCS
	{
		operation ast() : ocl::IfExp
		{
			body: ocl::IfExp {
				condition = condition.ast(),
				thenExpression = thenExpression.ast(),
				elseExpression = elseExpression.ast()
			};
		}
		property condition : ExpCS[?] { composes };
		property thenExpression : ExpCS[?] { composes };
		property elseExpression : ExpCS[?] { composes };
	}
	class IndexExpCS extends NamedExpCS
	{
		property firstIndexes : ExpCS[+] { ordered composes };
		property secondIndexes : ExpCS[*] { ordered composes };
		attribute atPre : Boolean[?] = 'false';
	}
	class InfixExpCS extends ExpCS
	{
		operation ast() : ocl::OperationCallExp
		{
			body: let first : ExpCS = ownedExpression->first(),
					others : Sequence(ExpCS) = ownedExpression->excluding(first)
				in  others->iterate(x : ExpCS; result : ocl::OperationCallExp = null |
					if result.oclIsUndefined()
					then result = ocl::OperationCallExp {
						name = ownedOperator->at(others->indexOf(x)),
						source = first.ast(),
						argument = Sequence(ocl::OperationCallExp) {x.ast()}
						-- referred operation = name resolution
					}
					else result = ocl::OperationCallExp {
						name = ownedOperator->at(others->indexOf(x)),
						source = result,
						argument = Sequence(ocl::OperationCallExp) {x.ast()}
						-- referredOperation = name resolution
					}
					endif);
		}
		property ownedExpression : ExpCS[2..*] { ordered composes };
		property ownedOperator : BinaryOperatorCS[+] { ordered composes };
	}
	
	class InvalidLiteralExpCS extends PrimitiveLiteralExpCS
	{
		operation ast() : ocl::InvalidLiteralExp {
			body : ocl::InvalidLiteralExp {
				type = OclInvalid
			};
		}
	}
	class InvocationExpCS extends NamedExpCS
	{
		/*
		 * FIXME TODO
		 */
		operation ast() : ocl::CallExp;
		
		property argument#navigatingExp : NavigatingArgCS[*] { ordered composes };
	}
	class LetExpCS extends ExpCS
	{
		operation ast() : ocl::LetExp
		{
			body: variable->reverse()->iterate(x : LetVariableCS; result : ocl::LetExp = null |
				if result.oclIsUndefined()
				then result = ocl::LetExp {
						variable = x.VariableCS::ast(),
						_'in' = self._'in'.ast()
					}
				else result = ocl::LetExp {
						variable = x.VariableCS::ast(),
						_'in' = result
					}	
				endif);
		}
		property variable#letExpression : LetVariableCS[*] { ordered composes };
		property _'in' : ExpCS[?] { composes };
	}
	class LetVariableCS extends VariableCS,ExpCS
	{
		--
		-- VariableCS ast() operation works for LetVariableCS
		--
		property letExpression#variable : LetExpCS[?];
	}
	class LiteralExpCS extends ExpCS;
	class NameExpCS extends AbstractNameExpCS
	{
		property pathName : basecs::basecs::PathNameCS[?] { composes };
		attribute atPre : Boolean[?] = 'false';
	}
	
	abstract class NamedExpCS extends AbstractNameExpCS
	{
		property nameExp : NameExpCS[?] { composes };
	}
	class NavigatingArgCS extends basecs::basecs::ModelElementCS
	{
		/*
		 * FIXME TODO
		 */
		operation ast(): ocl::OCLExpression;
		
		property navigatingExp#argument : InvocationExpCS[?];
		attribute role : NavigationRole[?] { derived transient };
		attribute prefix : String[?];
		property name : ExpCS[?] { composes };
		property ownedType : basecs::basecs::TypedRefCS[?] { composes };
		property init : ExpCS[?] { composes };
	}
	class NavigationOperatorCS extends BinaryOperatorCS;
	class NestedExpCS extends ExpCS
	{
		property source : ExpCS[?] { composes };
	}
	class NullLiteralExpCS extends PrimitiveLiteralExpCS
	{
		operation ast() : ocl::NullLiteralExp {
			body : 	ocl::NullLiteralExp {
				type = OclVoid
			};
		}
	}
	class NumberLiteralExpCS extends PrimitiveLiteralExpCS
	{
		operation ast() : ocl::NumericLiteralExp
		{
			body: ocl::IntegerLiteralExp {
				integerSymbol = name -- FIXME Integer/Real/
			};
		}
		attribute name : BigNumber[?];
	}
	abstract class OperatorCS extends ExpCS,basecs::basecs::NamedElementCS
	{
		property source : ExpCS { transient !resolve };
	}
	class PrefixExpCS extends ExpCS
	{
		operation ast() : ocl::OperationCallExp
		{
			body:	ownedOperator->reverse()->iterate(x : UnaryOperatorCS; result : ocl::OperationCallExp = null |
					if result.oclIsUndefined()
					then result = ocl::OperationCallExp {
							name = x.name,
							source = ownedExpression.ast()
							-- referredOperation = name resolution
						}
					else result = ocl::OperationCallExp {
							name = x.name,
							source = result
							-- referredOperation = name resolution
						}
					endif);
		}
		property ownedOperator : UnaryOperatorCS[*] { ordered composes };
		property ownedExpression : ExpCS[?] { composes };
	}
	class PrimitiveLiteralExpCS extends LiteralExpCS;
	class SelfExpCS extends ExpCS
	{
		operation ast() : ocl::VariableExp
		{
			body: let refVariable : ocl::VariableDeclaration = env().lookupVariableDeclaration(name)
					in ocl::VariableExp {
						referredVariable = refVariable, 
						type = refVariable.type 
					};
		}
		attribute name : String[?];
	}
	class StringLiteralExpCS extends PrimitiveLiteralExpCS
	{
		operation ast() : ocl::StringLiteralExp
		{
			body: ocl::StringLiteralExp {
				stringSymbol = name,
				type = String
			};
		}
		attribute name : String[*] { ordered !unique };
	}
	class TupleLiteralExpCS extends LiteralExpCS
	{
		operation ast() : ocl::TupleLiteralExp
		{
			body: ocl::TupleLiteralExp {
				part = ownedParts.ast()
				-- type = env().lookupTuple(ownedParts)
			};
		}
		property ownedParts : TupleLiteralPartCS[*] { ordered composes };
	}
	class TupleLiteralPartCS extends VariableCS
	{
		operation ast() : ocl::TupleLiteralPart
		{
			body: ocl::TupleLiteralPart {
				name = name,
				initExpression = initExpression,
				type = ownedType.ast()
			};
		}
	}
	class TypeLiteralExpCS extends LiteralExpCS
	{
		operation ast() : ocl::TypeExp
		{
			body: 
				let refType : ocl::Type = ownedType.ast()
				in ocl::TypeExp {
					referredType = refType,
					type = refType
					};
		}
		property ownedType : basecs::basecs::TypedRefCS { composes };
	}
	class TypeNameExpCS extends basecs::basecs::TypedRefCS
	{
		property pathName : basecs::basecs::PathNameCS[?] { composes };
		property element : ocl::Type[?] { derived readonly transient volatile !resolve };
	}
	class UnaryOperatorCS extends OperatorCS;
	class UnlimitedNaturalLiteralExpCS extends PrimitiveLiteralExpCS;
	class VariableCS extends basecs::basecs::NamedElementCS
	{
		operation ast() : ocl::Variable
		{
			body: ocl::Variable {
				name = name,
				initExpression = initExpression.ast(),
				type = ownedType.ast()
			};
		}
		property ownedType : basecs::basecs::TypedRefCS[?] { composes };
		property initExpression : ExpCS[?] { composes };
	}
	datatype BigNumber : 'java.lang.Number' { serializable };
	enum NavigationRole { serializable }
	{
		literal ITERATOR;
		literal ACCUMULATOR;
		literal EXPRESSION;
	}
}