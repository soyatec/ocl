// Copyright (c) 2013 Willink Transformations, University of York and others.
// All rights reserved. This program and the accompanying materials
// are made available under the terms of the Eclipse Public License v1.0
// which accompanies this distribution, and is available at
// http://www.eclipse.org/legal/epl-v10.html
// 
// Contributors:
// 		Adolfo Sanchez-Barbudo Herrera (Univerisity of York) - Initial API and implementation
import VisitorPatternLibrary;

modeltype ECORE "strict" uses ecore('http://www.eclipse.org/emf/2002/Ecore');

transformation VisitorPatternTransf(inout visitableModel : ECORE, inout rootVisitableModel : ECORE);

configuration property rootVisitorInterfaceName : String;
configuration property rootVisitorInterfaceQualifiedName : String;
configuration property visitorInterfaceName : String;
configuration property visitorInterfaceQualifiedName : String;
configuration property visitableInterfaceName : String;
configuration property visitableInterfaceQualifiedName : String;

main() {
	var rootVisitableClass : EClass := null;
	var rootVisitorClass : EClass := null;
	rootVisitableModel.rootObjects()[EPackage]->forEach(rootVisitablePackage) {
		rootVisitableClass := rootVisitablePackage.findClass(visitableInterfaceName, visitableInterfaceQualifiedName);
		if (rootVisitableClass = null) then {
			rootVisitablePackage.map addVisitableInterface(visitableInterfaceName, visitableInterfaceQualifiedName);
			// FIXME inout mapping doesnt return out result -> Bug ?, try out parameter
			rootVisitableClass := rootVisitablePackage.findClass(visitableInterfaceName, visitableInterfaceQualifiedName);
		} endif;
//		log('rootVisitableClass ' + rootVisitableClass.name);
		rootVisitorClass := rootVisitablePackage.findClass(rootVisitorInterfaceName, rootVisitorInterfaceQualifiedName);
		if (rootVisitorClass = null) then {
			rootVisitablePackage.map addVisitorInterface(rootVisitorInterfaceName, rootVisitorInterfaceQualifiedName);
			// FIXME inout mapping doesnt return out result -> Bug ?, try out parameter
			rootVisitorClass := rootVisitablePackage.findClass(rootVisitorInterfaceName, rootVisitorInterfaceQualifiedName);
		} endif;
//		log('rootVisitorClass ' + rootVisitorClass.name);
	};
	visitableModel.rootObjects()[EPackage]->forEach(visitablePackage) {
		var visitorClass := visitablePackage.findClass(visitorInterfaceName, visitorInterfaceQualifiedName);
		if (visitorClass = null) then {
			visitablePackage.map addVisitorInterface(visitorInterfaceName, visitorInterfaceQualifiedName);
			// FIXME inout mapping doesnt return out result -> Bug ?, try out parameter
			visitorClass := visitablePackage.findClass(visitorInterfaceName, visitorInterfaceQualifiedName);
		} endif;
//		log('visitorClass ' + visitorClass.name);
		var packageClasses := visitablePackage.eClassifiers[EClass]
			->excluding(visitorClass)
			->excluding(rootVisitableClass);
		packageClasses->map weaveAcceptMethod(visitorClass, rootVisitorClass);
		packageClasses->map weaveVisitableInterface(rootVisitableClass);
	};
}

mapping inout EPackage::addVisitorInterface(in visitorName : String, 
		in visitorInstanceClassName : String) // FIXME see above <- : EClass
	when { self.eClassifiers->select(name = visitorName)->isEmpty(); }
{
	var visitor := object EClass {
		name := visitorName;
		instanceClassName := visitorInstanceClassName;
		_abstract := true;
		interface := true;
		eTypeParameters += object ETypeParameter {
			name := "R";
		};
	};
	self.eClassifiers += visitor;
}

mapping inout EPackage::addVisitableInterface(in visitableName : String, 
		in visitableInstanceClassName : String) 
	when { self.eClassifiers->select(name = visitableName)->isEmpty(); }
{
	var visitable := object EClass {
		name := visitableName;
		instanceClassName := visitableInstanceClassName;
		_abstract := true;
		interface := true;
	};
	self.eClassifiers += visitable;
}

mapping inout EClass::weaveAcceptMethod(in visitorClass: EClass, in rootVisitorClass: EClass) 
	when { self.eOperations->select(name = 'accept')->isEmpty(); } 
{
	var acceptOp := object EOperation {
		name := 'accept';
		var typeParameter = object ETypeParameter {
			name := visitorClass.eTypeParameters->first().name;
		};
		eTypeParameters += typeParameter;
		eGenericType := object EGenericType {
			eTypeParameter := typeParameter;
		};
		lowerBound := 0;
		upperBound := 1;
		
		eParameters += object EParameter {
			name := "visitor";
			eGenericType := object EGenericType {
				eClassifier := rootVisitorClass;
				eTypeArguments := object EGenericType {
					eTypeParameter := typeParameter;
				}
			};
			lowerBound := 1;
			upperBound := 1;
		};
		
		var body := if visitorClass <> rootVisitorClass
		then "return (R) ((" + visitorClass.name + "<?>)visitor).visit" + self.name + "(this);"
		else "return visitor.visit" + self.name + "(this);" endif;
		eAnnotations += createGenModelBodyAnnotation(body);
	};
	eOperations += acceptOp;
}

mapping inout EClass::weaveVisitableInterface(in visitableClass: EClass) 
	when { self.eSuperTypes->select(not interface)->isEmpty() } 
{
	self.eSuperTypes += visitableClass;
}
