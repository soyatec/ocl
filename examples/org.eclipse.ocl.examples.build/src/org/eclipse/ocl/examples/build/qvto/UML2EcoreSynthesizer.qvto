
modeltype UML2Ecore uses 'http://www.eclipse.org/ocl/2012/UML2EcoreMapping';
modeltype UML uses 'http://www.eclipse.org/uml2/4.0.0/UML';
modeltype Ecore uses 'http://www.eclipse.org/emf/2002/Ecore';

transformation PruneUML(in analysis : UML2Ecore, out Ecore);

property mappings : Set(UML2Ecore::Mapping) = analysis.objectsOfType(UML2Ecore::Mappings).mappings->asSet();
property createPackages : Set(UML2Ecore::CreatePackage) = mappings->select(oclIsKindOf(UML2Ecore::CreatePackage)).oclAsType(UML2Ecore::CreatePackage)->asSet();
--property createTypes : Set(UML2Ecore::CreateType) = analysis.objectsOfType(UML2Ecore::CreateType)->asSet();

property packageMappings : Set(UML2Ecore::PackageMapping) = analysis.objectsOfType(UML2Ecore::PackageMapping);
property deletePackageMappings : Set(UML2Ecore::DeletePackage) = analysis.objectsOfType(UML2Ecore::DeletePackage);
property renamePackageMappings : Set(UML2Ecore::CreatePackage) = analysis.objectsOfType(UML2Ecore::CreatePackage);
property deleteTypeMappings : Set(UML2Ecore::DeleteType) = analysis.objectsOfType(UML2Ecore::DeleteType);
property createTypeMappings : Set(UML2Ecore::CreateType) = analysis.objectsOfType(UML2Ecore::CreateType);

property oldPackages : Set(UML::Package) = packageMappings.oldPackages->asSet();
property nestingPackages : Set(UML::Package) = oldPackages->closure(nestingPackage);
property allPackages : Set(UML::Package) = nestingPackages->closure(nestedPackage)->union(nestingPackages);
property deletePackages : Set(UML::Package) = deletePackageMappings.oldPackages->asSet();
property renamePackages : Set(UML::Package) = renamePackageMappings.oldPackages->asSet();
property copyPackages : Set(UML::Package) = allPackages - deletePackages - renamePackages;

property allTypes : Set(UML::Type) = allPackages.ownedType->asSet();
property allClasses : Set(UML::Class) = allPackages.ownedType->select(oclIsKindOf(UML::Class)).oclAsType(UML::Class)->asSet();

property deleteTypes : Set(UML::Type) = deleteTypeMappings.oldTypes->union(deleteTypeMappings.oldTypes)->asSet();
property deleteTypeNames : Set(String) = deleteTypes.name->asSet();
property deleteClasses : Set(UML::Class) = deleteTypeMappings.oldTypes->select(oclIsKindOf(UML::Class)).oclAsType(UML::Class)->asSet();

property umlType2createType : Dict(UML::Type, UML2Ecore::CreateType) = Dict{};



main() {
	--
	-- Pass 0: Analyze the input model and select the required elements
	--
--	log('packageMappings', packageMappings);
--	log('deletePackages', deletePackages.name->asSet()->sortedBy(n | n));
--	log('renamePackages', renamePackages.name->asSet()->sortedBy(n | n));
--	log('copyPackages', copyPackages.name->asSet()->sortedBy(n | n));
--	log('nestingPackages', nestingPackages.name->asSet()->sortedBy(n | n));
--	log('allPackages', allPackages.name->asSet()->sortedBy(n | n));
--	log('deleteTypes', deleteTypes.name->asSet());
--	log('createPackages', createPackages.newName->asSet());
--	log('createTypeMappings', createTypeMappings.newName->asSet());
	createTypeMappings->forEach(createType) {
		createType.oldTypes->forEach(oldType) {
			umlType2createType->put(oldType, createType);
		};
	};
	--	log('oldType2createType', oldType2createType);
	--
	-- Pass 1: Create the output containment hierarchy
	--
	createPackages->map createPackage();
	--
	-- Pass 2: Resolve references within the output containment hierarchy
	--
	umlType2eClass->values()->sortedBy(name)->map resolveEClass();
	umlProperty2eReference->values()->sortedBy(name)->map resolveEReference();
--	object Comment { body := 'association keys size = ' + out2in->keys()->select(oclIsKindOf(Association))->size().toString(); };
}

/**
 * Pass 1 convert the containment tree.
 */
mapping UML2Ecore::CreatePackage::createPackage() : Ecore::EPackage
{
--	self.oldPackages->forEach(p) { umlPackage2ePackage->put(p, result); };
	var createTypes : Set(UML2Ecore::CreateType) := self.typeMappings->select(oclIsKindOf(UML2Ecore::CreateType)).oclAsType(UML2Ecore::CreateType)->asSet();
--	self.convertNamedElement(result);
	result.name := self.newName;
	result.nsURI := self.nsURI;
	result.nsPrefix := self.nsPrefix;
	result.eClassifiers += createTypes->select(let t = oldTypes->any(true) in t.oclIsKindOf(UML::DataType) and not t.oclIsKindOf(UML::Enumeration))->createType(self)->sortedBy(name);
	result.eClassifiers += createTypes->select(oldTypes->any(true).oclIsKindOf(UML::Enumeration))->createType(self)->sortedBy(name);
--	result.eClassifiers += createTypes->select(oldTypes->any(true).oclIsKindOf(UML::Interface))->createType(self)->sortedBy(name);
	result.eClassifiers += createTypes->select(oldTypes->any(true).oclIsKindOf(UML::Class) or oldTypes->any(true).oclIsKindOf(UML::Interface))->createType(self)->sortedBy(name);
	result.eAnnotations += object Ecore::EAnnotation {
		source := 'http://www.eclipse.org/ocl/2012/UML2EcoreMapping';
		_references := self.oldPackages->sortedBy(name).oclAsType(ecore::EObject);
	};
}

helper UML2Ecore::CreateType::createType(createPackage : UML2Ecore::CreatePackage) : Ecore::EClassifier
{
	return self.oldTypes->at(1).map createType(self);
--	result.eAnnotations += object Ecore::EAnnotation {
--		source := 'http://www.eclipse.org/ocl/2012/UML2EcoreMapping';
--		_references := self.oldTypes->sortedBy(name).oclAsType(ecore::EObject);
--	}
}
mapping UML::Type::createType(createType : UML2Ecore::CreateType) : Ecore::EClassifier
disjuncts UML::Class::createClass, UML::Interface::createInterface, UML::Enumeration::createEnumeration, UML::DataType::createDataType;
abstract mapping UML::Type::createAbstractType(createType : UML2Ecore::CreateType) : Ecore::EClassifier
{
--	log('  createAbstractType', self.name);
	result.name := self.name;
	result.map installComments(createType.oldTypes.ownedComment->asSet());
	createType.oldTypes->forEach(t) { umlType2eClassifier->put(t, result); };
	eClassifier2createType->put(result, createType);
}
mapping UML::Class::createClass(createType : UML2Ecore::CreateType) : Ecore::EClass
inherits UML::Type::createAbstractType
{
--	log('  createClass', self.name);
	createType.oldTypes->forEach(t) { umlType2eClass->put(t, result); };
	result._'abstract' := createType.oldTypes->select(oclIsKindOf(UML::Class))->exists(oclAsType(UML::Class).isAbstract);
}
mapping UML::Interface::createInterface(createType : UML2Ecore::CreateType) : Ecore::EClass
inherits UML::Type::createAbstractType
{
--	log('  createInterface', self.name);
	createType.oldTypes->forEach(t) { umlType2eClass->put(t, result); };
	result.map installInstanceClassName(createType.oldTypes, 'Ecore::EClass');
	result._'abstract' := true;
	result.interface := true;
}

mapping UML::DataType::createDataType(createType : UML2Ecore::CreateType) : Ecore::EDataType
inherits UML::Type::createAbstractType
{
	result.map installInstanceClassName(createType.oldTypes, 'Ecore::EDataType');
}
mapping UML::Enumeration::createEnumeration(createType : UML2Ecore::CreateType) : Ecore::EEnum
inherits UML::Type::createAbstractType
{
	result.eLiterals := self.ownedLiteral->map createEnumerationLiteral();
}
 
mapping UML::EnumerationLiteral::createEnumerationLiteral() : Ecore::EEnumLiteral
{	
	var idx : Integer := self.enumeration.ownedLiteral->indexOf(self)-1;
--	log('  convertEnumerationLiteral', self.name + self.enumeration.ownedLiteral->iterate(l; acc : String = ':' | acc + ' ' + l.name) + ' / ' + idx.toString());
--	umlEnumerationLiteral2eEnumLiteral->put(self, result);
	result.name := self.name;
	result.map installComments(self.ownedComment);
	result.value := self.enumeration.ownedLiteral->indexOf(self)-1;
}

mapping UML2EcoreMapping::CreateProperty::createProperty(type : Ecore::EClassifier, oldProperties : Set(UML::Property), newType : Ecore::EClassifier) : Ecore::EStructuralFeature
disjuncts UML2EcoreMapping::CreateProperty::createAttribute, UML2EcoreMapping::CreateProperty::createReference;
mapping UML2EcoreMapping::CreateProperty::createAttribute(type : Ecore::EClassifier, oldProperties : Set(UML::Property), newType : Ecore::EClassifier) : Ecore::EAttribute
when { newType.oclIsKindOf(Ecore::EDataType) }
{
--	log('  createAttribute', self.newName);
	self.createStructuralFeature(result, oldProperties, newType);
	result.map installUnsettable(oldProperties, 'Ecore::EAttribute');
}
mapping UML2EcoreMapping::CreateProperty::createReference(type : Ecore::EClassifier, oldProperties : Set(UML::Property), newType : Ecore::EClassifier) : Ecore::EReference
when { not newType.oclIsKindOf(Ecore::EDataType) }
{
	oldProperties->forEach(p) { umlProperty2eReference->put(p, result); };
	eReference2createProperty->put(result, self);
	var oldProperty : Property := oldProperties->any(true);
--	log('  createReference', self.newName);
	self.createStructuralFeature(result, oldProperties, newType);
	result.map installUnsettable(oldProperties, 'Ecore::EReference');
	result.containment := oldProperty.aggregation = UML::AggregationKind::composite;
}

helper UML2EcoreMapping::CreateProperty::createStructuralFeature(inout output : Ecore::EStructuralFeature, oldProperties : Set(UML::Property), newType : Ecore::EClassifier)
{
	var oldProperty : Property := oldProperties->any(true);
	var defaultValues : Set(UML::ValueSpecification) := oldProperties.defaultValue->excluding(null)->asSet();
	output.name := self.newName;
	output.map installComments(oldProperties.ownedComment->asSet());
	output.lowerBound := oldProperty.lower;
	output.upperBound := oldProperty.upper;
	output.unique := oldProperty.isUnique;
	output._'ordered' := if (oldProperty.upper <= 1) then true else oldProperty.isOrdered endif;
	output.changeable := not oldProperty.isReadOnly;
	output._'derived' := oldProperty.isDerived;
--	output.unsettable := false; --oldProperty.lower < 1;
--	output.unsettable := false; --(oldProperty.lower = 1) and (oldProperty.upper = 1) and defaultValues->isEmpty() and output.oclIsKindOf(EAttribute); -- BooleanLiteralExp.booleanSymbol
--	log('    createStructuralFeature', Sequence{oldType, newType});
	output.eType := newType;
--	log('  defaultValues', defaultValues->iterate(l; acc : String = ':' | acc + ' ' + l.toString()));
	output.defaultValueLiteral := if defaultValues->notEmpty() then defaultValues->any(true).getDefaultValue() else null endif;
	return;
}

helper UML::ValueSpecification::getDefaultValue() : String
{
	return self.toString();
}
helper UML::LiteralBoolean::getDefaultValue() : String
{
	return self.value.toString();
}
helper UML::LiteralString::getDefaultValue() : String
{
	return self.value;
}

mapping inout Ecore::ENamedElement::installComments(in comments : Set(UML::Comment))
{
	var eComment : Ecore::EAnnotation := if comments->notEmpty() then object Ecore::EAnnotation {
		source := 'http://www.eclipse.org/emf/2002/GenModel';
		details += object Ecore::EStringToStringMapEntry {
			key := 'documentation';
			value := comments->iterate(c; acc : String = '' | acc + c.body)
		};
	} else null endif;
	self.eAnnotations += if eComment <> null then Set{eComment} else Set{} endif;
}

mapping inout Ecore::EClassifier::installInstanceClassName(in types : Set(UML::Type), stereotypeName : String)
{
	var stereotypedTypes : Set(UML::Type) := types->select(getAppliedStereotype(stereotypeName) <> null)->asSet();
	var stereotypedType : UML::Type := stereotypedTypes->any(true);
--	var stereotypes : Set(UML::Stereotype) := createType.oldTypes.oclAsType(UML::DataType).getAppliedStereotype('Ecore::EDataType')->asSet();
--	log('stereotypedType', stereotypedType);
	var instanceClassName : String := stereotypedType.getValue(stereotypedType.getAppliedStereotype(stereotypeName), 'instanceClassName').oclAsType(String);
--	log('instanceClassName', instanceClassName);
	self.instanceClassName := instanceClassName;
--	result.defaultValue := instanceClassName;
}

mapping inout Ecore::EStructuralFeature::installUnsettable(in properties : Set(UML::Property), stereotypeName : String)
{
	var stereotypedProperties : Set(UML::Property) := properties->select(getAppliedStereotype(stereotypeName) <> null)->asSet();
	var stereotypedProperty : UML::Property := if stereotypedProperties->notEmpty() then stereotypedProperties->any(true) else null endif;
--	var stereotypes : Set(UML::Stereotype) := createType.oldTypes.oclAsType(UML::DataType).getAppliedStereotype('Ecore::EDataType')->asSet();
--	log('stereotypedType', stereotypedType);
	var unsettable : Boolean := stereotypedProperty <> null and stereotypedProperty.getValue(stereotypedProperty.getAppliedStereotype(stereotypeName), 'isUnsettable').oclAsType(Boolean);
--	log('instanceClassName', instanceClassName);
	self.unsettable := unsettable ;
--	result.defaultValue := instanceClassName;
}

/**
 *	Pass 1 results for use in pass 2.
 */
property umlType2eClassifier : Dict(UML::Type, Ecore::EClassifier) = Dict{};
property umlType2eClass : Dict(UML::Type, Ecore::EClass) = Dict{};
--property umlEnumerationLiteral2eEnumLiteral : Dict(UML::EnumerationLiteral, Ecore::EEnumLiteral) = Dict{};
--property umlPackage2ePackage : Dict(UML::Package, Ecore::EPackage) = Dict{};
property umlProperty2eReference : Dict(UML::Property, Ecore::EReference) = Dict{};

property eClassifier2createType : Dict(Ecore::EClassifier, UML2Ecore::CreateType) = Dict{};
--property ePackage2createPackage : Dict(Ecore::EPackage, UML2Ecore::CreatePackage) = Dict{};
property eReference2createProperty : Dict(Ecore::EReference, UML2Ecore::CreateProperty) = Dict{};

/**
 * Pass 2 install all references.
 */
mapping inout Ecore::EClass::resolveEClass()
{
--	log('resolveElement', self.name);
	var createType : UML2Ecore::CreateType := eClassifier2createType->get(self);
	var allOldTypes : Set(UML::Type) := getAllTypes(createType.oldTypes);
--	log('  allOldTypes', allOldTypes->sortedBy(name)->iterate(n; acc : String = '' | acc + ' ' + name));
	var oldProperSuperClassClosure2 : Set(UML::Type) := getProperSuperTypes(allOldTypes);
--	log('  oldProperSuperClassClosure', oldProperSuperClassClosure2.name->asSet()->sortedBy(n | n)->iterate(n; acc : String = '' | acc + ' ' + n));
	var newSuperClassClosure : Set(UML::Type) := oldProperSuperClassClosure2->reject(deleteTypeNames->includes(name))-createType.oldTypes;
	var newProperSuperClassClosure : Set(UML::Type) := getAllTypes(newSuperClassClosure);
--	log('  newProperSuperClassClosure', newProperSuperClassClosure->sortedBy(name)->iterate(c; acc : String = '' | acc + ' ' + c.name));
	var newSuperSuperClassClosure2 : Set(UML::Type) := getProperSuperTypes(newProperSuperClassClosure);
--	log('  newSuperSuperClassClosure', newSuperSuperClassClosure2->sortedBy(name)->iterate(c; acc : String = '' | acc + ' ' + c.name));
	var requiredSuperClasses : Set(UML::Type) := newProperSuperClassClosure - newSuperSuperClassClosure2;
--	log('  requiredSuperClasses', requiredSuperClasses->sortedBy(name)->iterate(c; acc : String = '' | acc + ' ' + c.name));
	self.eSuperTypes := requiredSuperClasses->collect(sc | umlType2eClass->get(sc))->asSet()->sortedBy(sc | if sc.oclIsKindOf(UML::Class) then sc.name else '_'+sc.name endif);
	var oldInheritedClasses : Set(UML::Type) := createType.oldTypes->union(oldProperSuperClassClosure2);
--	log('  oldInheritedClasses', oldInheritedClasses->sortedBy(name)->iterate(c; acc : String = '' | acc + ' ' + c.name));
	var newInheritedClasses : Set(UML::Type) := requiredSuperClasses->union(getProperSuperTypes(requiredSuperClasses));
--	log('  newInheritedClasses', newInheritedClasses->sortedBy(name)->iterate(c; acc : String = '' | acc + ' ' + c.name));
	var mergedClasses : Set(UML::Type) := oldInheritedClasses - newInheritedClasses;
--	log('  mergedClasses', mergedClasses->sortedBy(name)->iterate(c; acc : String = '' | acc + ' ' + c.name));
	var mergedCreateTypes : Set(UML2EcoreMapping::CreateType) := mergedClasses->collect(t | if umlType2createType->hasKey(t) then umlType2createType->get(t) else null endif)->excluding(null)->asSet();
--	log('  mergedCreateTypes', mergedCreateTypes->sortedBy(newName)->iterate(c; acc : String = '' | acc + ' ' + c.newName));
	var inheritedCreateTypes : Set(UML2EcoreMapping::CreateType) := newProperSuperClassClosure->collect(t | if umlType2createType->hasKey(t) then umlType2createType->get(t) else null endif)->excluding(null)->asSet();
--	log('  inheritedCreateTypes', inheritedCreateTypes->sortedBy(newName)->iterate(c; acc : String = '' | acc + ' ' + c.newName));
	var propertyCreates  : Set(UML2EcoreMapping::CreateProperty) := mergedCreateTypes.propertyMappings->select(oclIsKindOf(UML2EcoreMapping::CreateProperty)).oclAsType(UML2EcoreMapping::CreateProperty)->asSet();
--	log('  propertyCreates', propertyCreates->sortedBy(newName)->iterate(c; acc : String = '' | acc + ' ' + c.newName));
	var inheritedPropertyCreates  : Set(UML2EcoreMapping::CreateProperty) := inheritedCreateTypes.propertyMappings->select(oclIsKindOf(UML2EcoreMapping::CreateProperty)).oclAsType(UML2EcoreMapping::CreateProperty)->asSet();
--	log('  inheritedPropertyCreates', inheritedPropertyCreates->sortedBy(newName)->iterate(c; acc : String = '' | acc + ' ' + c.newName));
	var propertyCreateNames  : Set(String) := propertyCreates.newName->asSet();
--	log('  propertyCreateNames', propertyCreateNames->sortedBy(n | n)->iterate(c; acc : String = '' | acc + ' ' + c));
	var inheritedPropertyCreateNames  : Set(String) := inheritedPropertyCreates.newName->asSet();
--	log('  inheritedPropertyCreateNames', inheritedPropertyCreateNames->sortedBy(n | n)->iterate(c; acc : String = '' | acc + ' ' + c));
	var localPropertyCreateNames  : Set(String) := propertyCreateNames - inheritedPropertyCreateNames;
--	log('  localPropertyCreateNames', localPropertyCreateNames->sortedBy(n | n)->iterate(c; acc : String = '' | acc + ' ' + c));
	var localPropertyCreates  : Set(UML2EcoreMapping::CreateProperty) := propertyCreates->select(localPropertyCreateNames->includes(newName));
--	log('  localPropertyCreates', localPropertyCreates->sortedBy(newName)->iterate(c; acc : String = '' | acc + ' ' + c.newName));
	localPropertyCreates->sortedBy(newName)->forEach(pc) {
		var oldProperty : Property := pc.oldProperties->any(true);
		var oldType : UML::Type := oldProperty.type;
		var newType : Ecore::EClassifier := umlType2eClassifier->get(oldType);
		if (newType <> null) then {
			self.eStructuralFeatures += pc.map createProperty(self, pc.oldProperties, newType);
		} endif;
	};
}

mapping inout Ecore::EReference::resolveEReference()
{
--	log('resolveElement', self.name);
	var createProperty : UML2EcoreMapping::CreateProperty := eReference2createProperty->get(self);
	var oldProperties : Set(UML::Property) := createProperty.oldProperties;
--	log('  oldProperties', oldProperties->sortedBy(name)->iterate(c; acc : String = '' | acc + ' ' + c.name));
	var oppositeProperties : Set(UML::Property) := oldProperties->collect(opposite)->excluding(null)->asSet();
--	log('  oppositeProperties', oppositeProperties->sortedBy(name)->iterate(c; acc : String = '' | acc + ' ' + c.name));
	var oppositeReferences : Set(Ecore::EReference) := oppositeProperties->collect(c | umlProperty2eReference->get(c))->asSet();
--	log('  oppositeReferences', oppositeReferences->sortedBy(name)->iterate(c; acc : String = '' | acc + ' ' + c.name));
	self.eOpposite := if oppositeReferences->notEmpty() and not self._'derived' and oppositeReferences->forAll(not _'derived') then oppositeReferences->any(true) else null endif;
}

helper getAllClasses(classes : Set(UML::Class)) : Set(UML::Class) {
	return getAllTypes(classes)->select(oclIsKindOf(UML::Class)).oclAsType(UML::Class)->asSet();
}
  
helper getAllTypes(types : Set(UML::Type)) : Set(UML::Type) {
	return getAllTypes(types.name->asSet());
}
  
helper getAllTypes(names : Set(String)) : Set(UML::Type) {
--	log('  types', types->sortedBy(name)->iterate(t; acc : String = '' | acc + ' ' + t._package.name + '::' + t.name));
	return allTypes->select(names->includes(name));
}

helper getProperSuperTypes(types : Set(UML::Type)) : Set(UML::Type) {
--	log('  types', types->sortedBy(name)->iterate(t; acc : String = '' | acc + ' ' + t._package.name + '::' + t.name));
	var classes : Set(UML::Class) := types->select(oclIsKindOf(UML::Class)).oclAsType(UML::Class)->asSet();
	var selfClasses : Set(UML::Class) := getAllClasses(classes);
	var properSuperClassClosure1 : Set(UML::Class) := getAllClasses(selfClasses->closure(superClass));
	var properSuperClassClosure2 : Set(UML::Class) := getAllClasses(properSuperClassClosure1->closure(superClass))->union(properSuperClassClosure1);
	var properSuperClassClosure : Set(UML::Class) := getAllClasses(properSuperClassClosure2->closure(superClass))->union(properSuperClassClosure2);
	var interfaceRealizations : Set(UML::InterfaceRealization) := properSuperClassClosure->union(selfClasses).interfaceRealization->asSet()->excluding(null);
--	log('  interfaceRealizations', interfaceRealizations);
	var superInterfaces : Set(UML::Interface) := interfaceRealizations.contract->asSet();
--	log('  superInterfaces', superInterfaces.name->asSet()->sortedBy(n | n)->iterate(n; acc : String = '' | acc + ' ' + n));
	var names : Set(String) := properSuperClassClosure.name->union(superInterfaces.name)->asSet();
	return getAllTypes(names);
}