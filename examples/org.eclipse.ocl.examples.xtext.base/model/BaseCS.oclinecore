import ecore : 'http://www.eclipse.org/emf/2002/Ecore';

package basecs : basecs = 'http://www.eclipse.org/ocl/3.1.0/BaseCST'
{
	class AnnotationCS extends AnnotationElementCS
	{
		operation ast() : ocl::Annotation {
			body : ocl::Annotation {
						name = name,
						ownedDetail = ownedDetail.ast(),
						ownedContent = ownedContent.ast(),
						ownedAnnotation = ownedAnnotation.ast(),
						reference = ownedReference.ast()
					};
		}
		property ownedContent : ModelElementCS[*] { ordered composes !resolve };
		property ownedReference : ModelElementRefCS[*] { ordered composes !resolve };
	}
	abstract class AnnotationElementCS extends NamedElementCS
	{
		property ownedDetail : DetailCS[*] { ordered composes !resolve };
	}
	class AttributeCS extends StructuralFeatureCS {
		operation ast() : ocl::Property {
			body : ocl::Property {
				name = name,
				isComposite = qualifier->exists(x|x = 'composite'),
				isDerived = qualifier->exists(x|x = 'derived'),
				isID = qualifier->exists(x|x = 'id'),
				isReadOnly = qualifier->exists(x|x = 'readonly'),
				isTransient = qualifier->exists(x|x = 'transient'),
				isUnsettable = qualifier->exists(x|x = 'unsettable'),
				isVolatile = qualifier->exists(x|x = 'volatile'),
				default = default,
				defaultExpression = ownedDefaultExpression.ast(),
				ownedAnnotation = ownedAnnotation.ast(),
				type = ownedType.ast()
			};
		}
	}
	class ClassCS extends ClassifierCS,NamespaceCS
	{
		operation ast() : ocl::Class
		{
			body: ocl::Class {
				name = name,
				instanceClassName = instanceClassName,
				isAbstract = qualifier->exists(x|x ='abstract'),
				isInterface = qualifier->exists(x|x = 'interface'),
				ownedTemplateSignature = ownedTemplateSignature.ast(),
				ownedAnnotation = ownedAnnotation.ast(),
				ownedOperation = ownedOperation.ast(),
				ownedAttribute = ownedProperty.ast(),
				ownedInvariant = ownedConstraint.ast(),
				superClass = ownedSuperType.ast()
			};
		}
		property ownedSuperType : TypedRefCS[*] { ordered unsettable composes };
		property ownedOperation#owningClass : OperationCS[*] { ordered composes !resolve };
		property ownedProperty#owner : StructuralFeatureCS[*] { ordered composes !resolve };
		property ownedMetaType : TypedRefCS[?] { composes };
	}
	abstract class ClassifierCS extends NamedElementCS,TypeCS,TemplateableElementCS
	{
		/*
		 * abstract
		 */
		operation ast() : ocl::Type;
		property owner#ownedType : PackageCS[?];
		attribute instanceClassName : String[?] { unsettable }
		{
			annotation _'http://www.eclipse.org/emf/2002/GenModel'
			(
				suppressedIsSetVisibility = 'true',
				suppressedUnsetVisibility = 'true'
			);
		}
		property ownedConstraint : ConstraintCS[*] { ordered composes !resolve };
		attribute qualifier : String[*] { ordered };
	}
	class ConstraintCS extends NamedElementCS
	{
		/*
		 * TODO
		 */
		operation ast() : ocl::OpaqueExpression;
		
		attribute stereotype : String[?];
		property specification : SpecificationCS[?] { composes };
		property messageSpecification : SpecificationCS[?] { composes };
	}
	class DataTypeCS extends ClassifierCS,NamespaceCS
	{
		operation ast() : ocl::DataType {
			body : ocl::DataType { 
				name = name,
				ownedTemplateSignature = ownedTemplateSignature,
				instanceClassName = instanceClassName,
				isSerializable = not qualifier->exists(x|x = '!serializable'),
				ownedAnnotation = ownedAnnotation.ast(),
				ownedInvariant = ownedConstraint.ast()
			};
		} 
		property literals : EnumerationLiteralCS[*] { ordered composes !resolve };
	}
	class DetailCS extends NamedElementCS
	{		
		operation ast() : ocl::Detail {
			body : ocl::Detail {
				name = name,
				value = value
			};
		}
		attribute value : String[*] { ordered };
	}
	class DocumentationCS extends AnnotationElementCS
	{
		/*
		 * TODO
		 */
		operation ast() : ocl::Annotation;
		attribute value : String[?];
	}
	abstract class ElementCS extends VisitableCS
	{
		operation getDescription() : String[?];
		operation env() : Environment[?];
		property logicalParent : ElementCS[?] { derived readonly transient volatile !resolve };
	}
	abstract class ElementRefCS extends PivotableElementCS;
	class EnumerationCS extends ClassifierCS,NamespaceCS
	{
		operation ast() : ocl::Enumeration
		{
			body: ocl::Enumeration {
				name = name,
				ownedLiteral = ownedLiterals.ast()
			};
		}
		property ownedLiterals : EnumerationLiteralCS[*] { ordered composes !resolve };
	}
	class EnumerationLiteralCS extends NamedElementCS
	{
		operation ast() : ocl::EnumerationLiteral
		{
			body: ocl::EnumerationLiteral {
				name = name,
				value = value,
				ownedAnnotation = ownedAnnotation
			};
		}
		attribute value : ecore::EInt[?];
	}
	abstract class FeatureCS extends TypedElementCS { interface };
	class ImportCS extends NamespaceCS
	{
		property pathName : PathNameCS[?] { composes };
		property namespace : ocl::Namespace[?] { derived readonly transient volatile !resolve };
		attribute all : Boolean[?] = 'false' { transient };
	}
	class LambdaTypeCS extends TypedRefCS,TemplateableElementCS,ocl::Nameable
	{
		attribute name : String[?];
		property ownedContextType : TypedRefCS[?] { composes };
		property ownedParameterType : TypedRefCS[*] { ordered composes !resolve };
		property ownedResultType : TypedRefCS[?] { composes };
	}
	class LibraryCS extends NamespaceCS
	{
		property package : ocl::Namespace[?];
	}
	abstract class ModelElementCS extends PivotableElementCS
	{
		/*
		 * abstract
		 */
		operation ast() : ocl::Element;
		property ownedAnnotation : AnnotationElementCS[*] { ordered composes !resolve };
		attribute originalXmiId : String[?] { transient };
		attribute csi : String[?] { transient };
	}
	class ModelElementRefCS extends ElementRefCS
	{
		/*
		 * TODO
		 */
		operation ast() : ocl::Element; 
		property pathName : PathNameCS[?] { composes };
		property element : ocl::Element[?] { derived readonly transient volatile !resolve };
	}
	class MultiplicityBoundsCS extends MultiplicityCS
	{
		attribute lowerBound : ecore::EInt[?] = '1';
		attribute upperBound : ecore::EIntegerObject[?];
	}
	abstract class MultiplicityCS extends ElementCS { interface }
	{
		operation getLower() : ecore::EInt;
		operation getUpper() : ecore::EInt;
	}
	class MultiplicityStringCS extends MultiplicityCS
	{
		attribute stringBounds : String[?] = '1';
	}
	abstract class NamedElementCS extends ModelElementCS,ocl::Nameable
	{
		attribute name : String[?];
	}
	abstract class NamespaceCS extends NamedElementCS { interface };
	class OperationCS extends FeatureCS,TemplateableElementCS
	{
		operation ast() : ocl::Operation
		{
			body: ocl::Operation {
				-- TODO
				name = name
			};
		}
		property owningClass#ownedOperation : ClassCS[?];
		property ownedParameter#owner : ParameterCS[*] { ordered composes !resolve };
		property ownedException : TypedRefCS[*] { ordered composes };
		property ownedPrecondition : ConstraintCS[*] { ordered composes !resolve };
		property ownedPostcondition : ConstraintCS[*] { ordered composes !resolve };
		property ownedBodyExpression : SpecificationCS[*] { ordered composes !resolve };
	}
	class PackageCS extends PackageOwnerCS,NamespaceCS
	{
		operation ast() : ocl::Package
		{
			body: ocl::Package{
				-- TODO
				name = name,
				nestedPackage = ownedNestedPackage.ast()
			};
		}
		operation getClassifier(name : String[?]) : ClassifierCS[?];
		property ownedType#owner : ClassifierCS[*] { ordered composes };
		attribute nsPrefix : String[?];
		attribute nsURI : String[?];
	}
	abstract class PackageOwnerCS extends ModelElementCS
	{
		property ownedNestedPackage : PackageCS[*] { ordered composes };
	}
	class ParameterCS extends TypedElementCS
	{
		operation ast() : ocl::Parameter
		{
			body: ocl::Parameter {
				-- TODO
				name = name
			};
		}
		property owner#ownedParameter : OperationCS[?];
	}
	class PathElementCS extends ElementCS,ocl::Pivotable
	{
		property pathName#path : PathNameCS;
		property element : ocl::Element;
		property elementType : ecore::EClassifier[?] { transient !resolve };
	}
	class PathElementWithURICS extends PathElementCS
	{
		attribute uri : String[?] { transient };
	}
	class PathNameCS extends ElementCS,ocl::Pivotable
	{
		property path#pathName : PathElementCS[+] { ordered composes !resolve };
		property element : ocl::Element { derived readonly transient volatile };
		property context : ElementCS[?] { transient unsettable !resolve };
		attribute scopeFilter : ScopeFilter[?] { transient };
	}
	abstract class PivotableElementCS extends ElementCS,ocl::Pivotable
	{
		property pivot : ocl::Element[?] { transient !resolve };
	}
	class PrimitiveTypeRefCS extends TypedRefCS,ocl::Nameable
	{
		operation ast() : ocl::PrimitiveType
		{
			body: ocl::PrimitiveType {
				name = name
			};
		}
		attribute name : String[?];
	}
	class ReferenceCS extends StructuralFeatureCS
	{
		property opposite : ocl::Property[?];
		property keys : ocl::Property[*] { ordered };
	}
	abstract class RootCS extends ModelElementCS { interface }
	{
		property ownedImport : ImportCS[*] { ordered composes };
		property ownedLibrary : LibraryCS[*] { ordered composes };
		invariant TestConstraint: true;
	}
	class RootPackageCS extends PackageOwnerCS,RootCS
	{
		invariant TestConstraint: true;
	}
	class SpecificationCS extends ModelElementCS
	{
		operation ast() : ocl::OpaqueExpression {
			body : ocl::OpaqueExpression {
				language = 'OCL',
				body = 	Sequence(String){exprString}
			};
		}
		attribute exprString : String[?];
	}
	abstract class StructuralFeatureCS extends FeatureCS
	{
		operation ast() : ocl::Property;
		property owner#ownedProperty : ClassCS[?];
		attribute default : String[?];
		property ownedDefaultExpression : SpecificationCS[*] { ordered composes !resolve };
	}
	class TemplateBindingCS extends ElementRefCS
	{
		property owningTemplateBindableElement#ownedTemplateBinding : TypedTypeRefCS[?];
		property ownedParameterSubstitution#owningTemplateBinding : TemplateParameterSubstitutionCS[*] { ordered composes };
	}
	abstract class TemplateParameterCS extends NamedElementCS
	{
		property owningTemplateSignature#ownedTemplateParameter : TemplateSignatureCS;
	}
	class TemplateParameterSubstitutionCS extends ModelElementCS
	{
		property owningTemplateBinding#ownedParameterSubstitution : TemplateBindingCS[?];
		property ownedActualParameter : TypeRefCS[?] { composes };
	}
	class TemplateSignatureCS extends ModelElementCS
	{
		property owningTemplateElement#ownedTemplateSignature : TemplateableElementCS[?];
		property ownedTemplateParameter#owningTemplateSignature : TemplateParameterCS[*] { ordered composes };
	}
	abstract class TemplateableElementCS extends ElementCS { interface }
	{
		property ownedTemplateSignature#owningTemplateElement : TemplateSignatureCS[?] { composes };
	}
	class TuplePartCS extends TypedElementCS
	{
		operation ast() : ocl::Property
		{
			body: ocl::Property {
				name = name,
				type = ownedType.ast()
			};
		}
	}
	class TupleTypeCS extends TypedRefCS,ocl::Nameable
	{
		operation ast() : ocl::TupleType
		{
			body: ocl::TupleType {
				name = name,
				ownedAttribute = ownedParts.ast()
			};
		}
		attribute name : String[?];
		property ownedParts : TuplePartCS[*] { ordered composes };
	}
	abstract class TypeCS extends ModelElementCS { interface };
	class TypeParameterCS extends TemplateParameterCS,TypeCS
	{
		property ownedExtends : TypedRefCS[*] { ordered composes };
		property ownedSuper : TypedRefCS[?] { composes };
	}
	abstract class TypeRefCS extends ElementRefCS
	{
		operation ast() : ocl::Type
		{
			body: true;
		}
	}
	abstract class TypedElementCS extends NamedElementCS
	{
		property ownedType : TypedRefCS[?] { composes };
		attribute qualifier : String[*] { ordered };
		attribute optional : Boolean[?];
	}
	abstract class TypedRefCS extends TypeRefCS
	{
		property multiplicity : MultiplicityCS[?] { composes !resolve };
	}
	class TypedTypeRefCS extends TypedRefCS
	{
		property pathName : PathNameCS[?] { composes };
		property type : ocl::Type[?] { derived readonly transient volatile !resolve };
		property ownedTemplateBinding#owningTemplateBindableElement : TemplateBindingCS[?] { composes };
	}
	abstract class VisitableCS : 'org.eclipse.ocl.examples.xtext.base.basecs.util.VisitableCS' { interface };
	class WildcardTypeRefCS extends TypeRefCS
	{
		property extends : TypedRefCS[?] { composes };
		property super : TypedRefCS[?] { composes };
	}
	enum IteratorKind { serializable }
	{
		literal Parameter;
		literal Iterator;
		literal Accumulator;
	}
	datatype ScopeFilter : 'org.eclipse.ocl.examples.pivot.scoping.ScopeFilter' { serializable };
	abstract class Environment { interface }
	{
		operation lookupLocal(name : String[?]) : NamedElementCS[?];
		operation lookup(name : String[?]) : ocl::NamedElement[?];
		operation lookupPathName(name : PathNameCS[?]) : ocl::NamedElement[?];
		operation lookupVariableDeclaration(name : String[?]) : ocl::VariableDeclaration[?];
		operation lookupType(name : String[?]) : ocl::VariableDeclaration[?];
		operation lookupType(name : PathNameCS[?]) : ocl::VariableDeclaration[?];
		operation lookupCollectionType(collectionKind : String[?], elementType : TypedRefCS[?]) : ocl::CollectionType[?];
	}
}