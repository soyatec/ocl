import ecore : 'http://www.eclipse.org/emf/2002/Ecore';

package basecs : basecs = 'http://www.eclipse.org/ocl/3.1.0/BaseCST'
{
	class AnnotationCS extends AnnotationElementCS
	{
		operation ast() : ocl::Annotation {
			body : ocl::Annotation {
						name = name,
						ownedDetail = ownedDetail.ast(),
						ownedContent = ownedContent.ast(),
						ownedAnnotation = ownedAnnotation.ast(),
						reference = ownedReference.ast()
					};
		}
		property ownedContent : ModelElementCS[*] { ordered composes !resolve };
		property ownedReference : ModelElementRefCS[*] { ordered composes !resolve };
	}
	abstract class AnnotationElementCS extends NamedElementCS
	{
		property ownedDetail : DetailCS[*] { ordered composes !resolve };
	}
	class AttributeCS extends StructuralFeatureCS {
		operation ast() : ocl::Property {
			body : ocl::Property {
				name = name,
				isComposite = qualifier->includes('composite'),
				isDerived = qualifier->includes('derived'),
				isID = qualifier->includes('id'),
				isReadOnly = qualifier->includes('readonly'),
				isTransient = qualifier->includes('transient'),
				isUnsettable = qualifier->includes('unsettable'),
				isVolatile = qualifier->includes('volatile'),
				default = default,
				defaultExpression = ownedDefaultExpression.ast(),
				ownedAnnotation = ownedAnnotation.ast(),				
				type = ownedType.ast()
				
			};
		}
	}
	class ClassCS extends ClassifierCS,NamespaceCS
	{
		operation ast() : ocl::Class
		{
			body: ocl::Class {
				name = name,
				instanceClassName = instanceClassName,
				isAbstract = qualifier->includes('abstract'),
				isInterface = qualifier->includes( 'interface'),
				ownedTemplateSignature = ownedTemplateSignature.ast(),
				ownedAnnotation = ownedAnnotation.ast(),
				ownedOperation = ownedOperation.ast(),
				ownedAttribute = ownedProperty.ast(),
				ownedInvariant = ownedConstraint.ast(),
				superClass = ownedSuperType.ast()
			};
		}
		property ownedSuperType : TypedRefCS[*] { ordered unsettable composes };
		property ownedOperation#owningClass : OperationCS[*] { ordered composes !resolve };
		property ownedProperty#owner : StructuralFeatureCS[*] { ordered composes !resolve };
		property ownedMetaType : TypedRefCS[?] { composes };
	}
	abstract class ClassifierCS extends NamedElementCS,TypeCS,TemplateableElementCS
	{
		/*
		 * abstract
		 */
		operation ast() : ocl::Type;
		property owner#ownedType : PackageCS[?];
		attribute instanceClassName : String[?] { unsettable }
		{
			annotation _'http://www.eclipse.org/emf/2002/GenModel'
			(
				suppressedIsSetVisibility = 'true',
				suppressedUnsetVisibility = 'true'
			);
		}
		property ownedConstraint : ConstraintCS[*] { ordered composes !resolve };
		attribute qualifier : String[*] { ordered };
	}
	class ConstraintCS extends NamedElementCS
	{
		/*
		 * TODO
		 */
		operation ast() : ocl::OpaqueExpression;
		
		attribute stereotype : String[?];
		property specification : SpecificationCS[?] { composes };
		property messageSpecification : SpecificationCS[?] { composes };
	}
	class DataTypeCS extends ClassifierCS,NamespaceCS
	{
		operation ast() : ocl::DataType {
			body : ocl::DataType { 
				name = name,
				ownedTemplateSignature = ownedTemplateSignature,
				instanceClassName = instanceClassName,
				isSerializable = not qualifier->includes('!serializable'),
				ownedAnnotation = ownedAnnotation.ast(),
				ownedInvariant = ownedConstraint.ast()
			};
		} 
		property literals : EnumerationLiteralCS[*] { ordered composes !resolve };
	}
	class DetailCS extends NamedElementCS
	{		
		operation ast() : ocl::Detail {
			body : ocl::Detail {
				name = name,
				value = value
			};
		}
		attribute value : String[*] { ordered };
	}
	class DocumentationCS extends AnnotationElementCS
	{
		/*
		 * TODO
		 */
		operation ast() : ocl::Annotation;
		attribute value : String[?];
	}
	abstract class ElementCS extends VisitableCS
	{
		operation getDescription() : String[?];
		operation env() : Environment[?];
		property logicalParent : ElementCS[?] { derived readonly transient volatile !resolve };
	}
	abstract class ElementRefCS extends PivotableElementCS;
	class EnumerationCS extends ClassifierCS,NamespaceCS
	{
		operation ast() : ocl::Enumeration
		{
			body: ocl::Enumeration {
				name = name,
				instanceClassName = instanceClassName,
				isSerializable = not qualifier->includes('!serializable'),
				ownedLiteral = ownedLiterals.ast(),
				ownedTemplateSignature = ownedTemplateSignature.ast(),
				ownedAnnotation = ownedAnnotation.ast(),
				ownedInvariant = ownedConstraint.ast()
			};
		}
		property ownedLiterals : EnumerationLiteralCS[*] { ordered composes !resolve };
	}
	class EnumerationLiteralCS extends NamedElementCS
	{
		operation ast() : ocl::EnumerationLiteral
		{
			body: ocl::EnumerationLiteral {
				name = name,
				value = value,
				ownedAnnotation = ownedAnnotation
			};
		}
		attribute value : ecore::EInt[?];
	}
	abstract class FeatureCS extends TypedElementCS { interface };
	class ImportCS extends NamespaceCS
	{
		operation ast() : ocl::Import 
		{
			body: ocl::Import {
				name = name,
				importedNamespace = namespace
				-- importedNamespace = env().lookupNamespace(pathName)
			};
		} 
		property pathName : PathNameCS[?] { composes };
		property namespace : ocl::Namespace[?] { derived readonly transient volatile !resolve };
		attribute all : Boolean[?] = 'false' { transient };
	}
	class LambdaTypeCS extends TypedRefCS,TemplateableElementCS,ocl::Nameable
	{
		operation ast()  :ocl::LambdaType {
			body : ocl::LambdaType {
				name = name,
				contextType = ownedContextType.ast(),
				parameterType = ownedParameterType.ast(),
				resultType = ownedResultType.ast()   
			};
		}
		attribute name : String[?];
		property ownedContextType : TypedRefCS[?] { composes };
		property ownedParameterType : TypedRefCS[*] { ordered composes !resolve };
		property ownedResultType : TypedRefCS[?] { composes };
	}
	class LibraryCS extends NamespaceCS
	{
		/*
		 * TODO -> OclLibrary
		 */
		operation ast() : ocl::Library;
		property package : ocl::Namespace[?];
	}
	abstract class ModelElementCS extends PivotableElementCS
	{
		/*
		 * abstract
		 */
		operation ast() : ocl::Element;
		property ownedAnnotation : AnnotationElementCS[*] { ordered composes !resolve };
		attribute originalXmiId : String[?] { transient };
		attribute csi : String[?] { transient };
	}
	class ModelElementRefCS extends ElementRefCS
	{
		operation ast() : ocl::Element {
			body : element;
		}
		
		property pathName : PathNameCS[?] { composes };
		property element : ocl::Element[?] { derived readonly transient volatile !resolve };
	}
	class MultiplicityBoundsCS extends MultiplicityCS
	{
		attribute lowerBound : ecore::EInt[?] = '1';
		attribute upperBound : ecore::EIntegerObject[?];
	}
	abstract class MultiplicityCS extends ElementCS { interface }
	{
		operation getLower() : ecore::EInt;
		operation getUpper() : ecore::EInt;
	}
	class MultiplicityStringCS extends MultiplicityCS
	{
		attribute stringBounds : String[?] = '1';
	}
	abstract class NamedElementCS extends ModelElementCS,ocl::Nameable
	{
		attribute name : String[?];
	}
	abstract class NamespaceCS extends NamedElementCS { interface };
	class OperationCS extends FeatureCS,TemplateableElementCS
	{
		operation ast() : ocl::Operation
		{
			body: ocl::Operation {
				name = name,
				isStatic = qualifier->includes( 'static'),
				ownedTemplateSignature = ownedTemplateSignature.ast(),
				ownedParameter = ownedParameter.ast(),
				raisedException = ownedException.ast(),
				ownedAnnotation = ownedAnnotation.ast(),
				precondition = ownedPrecondition.ast(),
				postcondition = ownedPostcondition.ast(),
				bodyExpression = ownedBodyExpression.ast(),
				type = ownedType.ast()
			};
		}
		property owningClass#ownedOperation : ClassCS[?];
		property ownedParameter#owner : ParameterCS[*] { ordered composes !resolve };
		property ownedException : TypedRefCS[*] { ordered composes };
		property ownedPrecondition : ConstraintCS[*] { ordered composes !resolve };
		property ownedPostcondition : ConstraintCS[*] { ordered composes !resolve };
		property ownedBodyExpression : SpecificationCS[*] { ordered composes !resolve };
	}
	class PackageCS extends PackageOwnerCS,NamespaceCS
	{
		operation ast() : ocl::Package
		{
			body: ocl::Package{				
				name = name,
				nsPrefix = nsPrefix,
				nsURI = nsURI,
				nestedPackage = ownedNestedPackage.ast(),
				ownedType = ownedType.ast()
			};
		}
		operation getClassifier(name : String[?]) : ClassifierCS[?];
		property ownedType#owner : ClassifierCS[*] { ordered composes };
		attribute nsPrefix : String[?];
		attribute nsURI : String[?];
	}
	abstract class PackageOwnerCS extends ModelElementCS
	{
		property ownedNestedPackage : PackageCS[*] { ordered composes };
	}
	class ParameterCS extends TypedElementCS
	{
		operation ast() : ocl::Parameter
		{
			body: ocl::Parameter {
				name = name,
				ownedAnnotation = ownedAnnotation.ast(),
				type = ownedType.ast()
			};
		}
		property owner#ownedParameter : OperationCS[?];
	}
	class PathElementCS extends ElementCS,ocl::Pivotable
	{
		property pathName#path : PathNameCS;
		property element : ocl::Element;
		property elementType : ecore::EClassifier[?] { transient !resolve };
	}
	class PathElementWithURICS extends PathElementCS
	{
		attribute uri : String[?] { transient };
	}
	class PathNameCS extends ElementCS,ocl::Pivotable
	{
		property path#pathName : PathElementCS[+] { ordered composes !resolve };
		property element : ocl::Element { derived readonly transient volatile };
		property context : ElementCS[?] { transient unsettable !resolve };
		attribute scopeFilter : ScopeFilter[?] { transient };
	}
	abstract class PivotableElementCS extends ElementCS,ocl::Pivotable
	{
		property pivot : ocl::Element[?] { transient !resolve };
	}
	class PrimitiveTypeRefCS extends TypedRefCS,ocl::Nameable
	{
		operation ast() : ocl::PrimitiveType
		{
			body: ocl::PrimitiveType {
				name = name
			};
		}
		attribute name : String[?];
	}
	class ReferenceCS extends StructuralFeatureCS
	{
		operation ast() : ocl::Property {
			body : ocl::Property {
				name = name,
				isStatic = qualifier->includes('static'),
				isComposite = qualifier->includes('composite'),
				isReadOnly = qualifier->includes('readonly'),
				isResolveProxies = not qualifier->exists( x | x = '!resolve'),
				isTransient = qualifier->includes('transient'),
				isUnsettable = qualifier->includes('unsettable'),
				isVolatile = qualifier->includes('volatile'),
				keys = keys, -- FIXME
				defaultExpression = if ownedDefaultExpression->notEmpty()
									then ownedDefaultExpression.ast()
									else null
									endif,
				type = ownedType.ast(),				
				opposite = if not (opposite = null)
				 		   then opposite
				 		   else ocl::Property {
										name = self.ast().owningType.name, -- FIXME hazard when having different types with same name => two properties with the same name
										implicit = true,
										isRequired = false,
										owningType = ownedType.ast()
										-- type = env().getCollectionType(ocl::CollectionKind::OrderedSet, thisType)
								}
							endif
			};
		}
		property opposite : ocl::Property[?];
		property keys : ocl::Property[*] { ordered };
	}
	abstract class RootCS extends ModelElementCS { interface }
	{
		property ownedImport : ImportCS[*] { ordered composes };
		property ownedLibrary : LibraryCS[*] { ordered composes };
		invariant TestConstraint: true;
	}
	class RootPackageCS extends PackageOwnerCS,RootCS
	{
		operation ast() : ocl::Root {
			body : ocl::Root {
				imports = ownedImport.ast(),
				nestedPackage = ownedNestedPackage.ast()
			};
		}
		invariant TestConstraint: true;
	}
	class SpecificationCS extends ModelElementCS
	{
		operation ast() : ocl::OpaqueExpression {
			body : ocl::OpaqueExpression {
				language = 'OCL',
				body = 	Sequence(String){exprString}
			};
		}
		attribute exprString : String[?];
	}
	abstract class StructuralFeatureCS extends FeatureCS
	{
		/*
		 * Abstract
		 */
		operation ast() : ocl::Property;
		property owner#ownedProperty : ClassCS[?];
		attribute default : String[?];
		property ownedDefaultExpression : SpecificationCS[*] { ordered composes !resolve };
	}
	class TemplateBindingCS extends ElementRefCS
	{
		operation ast() : ocl::TemplateBinding {
			body : ocl::TemplateBinding {
				parameterSubstitution = ownedParameterSubstitution.ast()
			};
		}
		property owningTemplateBindableElement#ownedTemplateBinding : TypedTypeRefCS[?];
		property ownedParameterSubstitution#owningTemplateBinding : TemplateParameterSubstitutionCS[*] { ordered composes };
	}
	abstract class TemplateParameterCS extends NamedElementCS
	{
		property owningTemplateSignature#ownedTemplateParameter : TemplateSignatureCS;
	}
	class TemplateParameterSubstitutionCS extends ModelElementCS
	{
		operation ast() : ocl::TemplateParameterSubstitution {
			body : ocl::TemplateParameterSubstitution {
				ownedActual = ownedActualParameter.ast()
			};
		}
		property owningTemplateBinding#ownedParameterSubstitution : TemplateBindingCS[?];
		property ownedActualParameter : TypeRefCS[?] { composes };
	}
	class TemplateSignatureCS extends ModelElementCS
	{
		operation ast() : ocl::TemplateSignature {
			body : ocl::TemplateSignature {
				ownedParameter = ownedTemplateParameter.ast()
			};
		}
		property owningTemplateElement#ownedTemplateSignature : TemplateableElementCS[?];
		property ownedTemplateParameter#owningTemplateSignature : TemplateParameterCS[*] { ordered composes };
	}
	abstract class TemplateableElementCS extends ElementCS { interface }
	{
		property ownedTemplateSignature#owningTemplateElement : TemplateSignatureCS[?] { composes };
	}
	class TuplePartCS extends TypedElementCS
	{
		operation ast() : ocl::Property
		{
			body: ocl::Property {
				name = name,
				type = ownedType.ast()
			};
		}
	}
	class TupleTypeCS extends TypedRefCS,ocl::Nameable
	{
		operation ast() : ocl::TupleType
		{
			body: ocl::TupleType {
				name = name,
				ownedAttribute = ownedParts.ast()
			};
		}
		attribute name : String[?];
		property ownedParts : TuplePartCS[*] { ordered composes };
	}
	abstract class TypeCS extends ModelElementCS { interface };
	class TypeParameterCS extends TemplateParameterCS,TypeCS
	{
		/*
		 * TODO
		 */
		operation ast() : ocl::TypeTemplateParameter {
			body : 	let parameteredElement = ocl::Class {
						name = self.name
					}
					in	ocl::TypeTemplateParameter {
						ownedParameteredElement = parameteredElement,
						parameteredElement = parameteredElement
					};
		}
		
		property ownedExtends : TypedRefCS[*] { ordered composes };
		property ownedSuper : TypedRefCS[?] { composes };
	}
	abstract class TypeRefCS extends ElementRefCS
	{
		/*
		 * abstract
		 */
		operation ast() : ocl::Type;		
	}
	abstract class TypedElementCS extends NamedElementCS
	{
		property ownedType : TypedRefCS[?] { composes };
		attribute qualifier : String[*] { ordered };
		attribute optional : Boolean[?];
	}
	abstract class TypedRefCS extends TypeRefCS
	{
		property multiplicity : MultiplicityCS[?] { composes !resolve };
	}
	class TypedTypeRefCS extends TypedRefCS
	{
		operation ast() : ocl::Type
		{
			body: type;
				-- env().lookupType(pathName);			
		}
		property pathName : PathNameCS[?] { composes };
		property type : ocl::Type[?] { derived readonly transient volatile !resolve };
		property ownedTemplateBinding#owningTemplateBindableElement : TemplateBindingCS[?] { composes };
	}
	abstract class VisitableCS : 'org.eclipse.ocl.examples.xtext.base.basecs.util.VisitableCS' { interface };
	class WildcardTypeRefCS extends TypeRefCS
	{
		/*
		 * TODO
		 */
		operation ast() : ocl::Type;	
		property extends : TypedRefCS[?] { composes };
		property super : TypedRefCS[?] { composes };
	}
	enum IteratorKind { serializable }
	{
		literal Parameter;
		literal Iterator;
		literal Accumulator;
	}
	datatype ScopeFilter : 'org.eclipse.ocl.examples.pivot.scoping.ScopeFilter' { serializable };
	abstract class Environment { interface }
	{
		operation lookupLocal(name : String[?]) : NamedElementCS[?];
		operation lookup(name : String[?]) : ocl::NamedElement[?];
		operation lookupPathName(name : PathNameCS[?]) : ocl::NamedElement[?];
		operation lookupVariableDeclaration(name : String[?]) : ocl::VariableDeclaration[?];
		operation lookupType(name : String[?]) : ocl::VariableDeclaration[?];
		operation lookupType(name : PathNameCS[?]) : ocl::VariableDeclaration[?];
		operation lookupCollectionType(collectionKind : String[?], elementType : TypedRefCS[?]) : ocl::CollectionType[?];
	}
}