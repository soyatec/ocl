import 'BaseCS.ecore'
import '/resource/org.eclipse.ocl.examples.pivot/model/Pivot.ecore'

package basecs

context  AnnotationCS
def: ast() : ocl::Annotation = 
	ocl::Annotation {
		name = name,
		ownedDetail = ownedDetail.ast(),
		ownedContent = ownedContent.ast(),
		ownedAnnotation = ownedAnnotation.ast(),
		reference = ownedReference.ast()
	}

context AttributeCS
def: ast() : ocl::Property= 
	ocl::Property {
		name = name,
		isStatic = qualifier->includes('static'),
		isDerived = qualifier->includes('derived'),
		isID = qualifier->includes('id'),
		isReadOnly = qualifier->includes('readonly'),
		isTransient = qualifier->includes('transient'),
		isUnsettable = qualifier->includes('unsettable'),
		isVolatile = qualifier->includes('volatile'),
		default = default,
		defaultExpression = ownedDefaultExpression.ast(),
		ownedAnnotation = ownedAnnotation.ast(),
		type = ownedType.ast(),
		owningType = if (qualifier->includes('definition'))
					 then null -- TODO Look for secondary type, create it if it doesn't exist
					 else null -- FIXME return null, it will be added by owning class afterwards. BUT it will do the same even though if we have previously added it to a secondary type as well !!! 
					 endif				
		
	}
	
context ClassCS
def: ast() : ocl::Class =
	ocl::Class {
		name = name,
		instanceClassName = instanceClassName,
		isAbstract = qualifier->includes('abstract'),
		isInterface = qualifier->includes( 'interface'),
		ownedTemplateSignature = ownedTemplateSignature.ast(),
		ownedAnnotation = ownedAnnotation.ast(),
		ownedOperation = ownedOperation.ast(),
		ownedAttribute = ownedProperty.ast(),
		ownedInvariant = ownedConstraint.ast(),
		superClass = ownedSuperType.ast()
	}

-- FIXME stereotype, messageSpacification is not used
context ConstraintCS
def : ast() : ocl::Constraint =
	ocl::Constraint { 
		specification = specification.ast()
	}
	
context DataTypeCS 
def: ast() : ocl::DataType =
	ocl::DataType { 
		name = name,
		ownedTemplateSignature = ownedTemplateSignature,
		instanceClassName = instanceClassName,
		isSerializable = not qualifier->includes('!serializable'),
		ownedAnnotation = ownedAnnotation.ast(),
		ownedInvariant = ownedConstraint.ast()
	}

context DetailCS
def: ast() : ocl::Detail = 
	ocl::Detail {
		name = name,
		value = value
	}
	
-- TODO: Obsolote. Remove from metamodel and/or grammar ?	
--context DocumentationCS 
--		

context ElementCS
def : env() : Environment[1] = 
	null -- TODO


--context ElementRefCS 

context EnumerationCS
def : ast() : ocl::Enumeration =
	ocl::Enumeration {
		name = name,
		instanceClassName = instanceClassName,
		isSerializable = not qualifier->includes('!serializable'),
		ownedLiteral = ownedLiterals.ast(),
		ownedTemplateSignature = ownedTemplateSignature.ast(),
		ownedAnnotation = ownedAnnotation.ast(),
		ownedInvariant = ownedConstraint.ast()
	}

context EnumerationLiteralCS
def : ast() : ocl::EnumerationLiteral =
	ocl::EnumerationLiteral {
				name = name,
				value = value,
				ownedAnnotation = ownedAnnotation
	}

--context	FeatureCS
context ImportCS
def : ast() : ocl::Import =
	ocl::Import {
		name = name,
		importedNamespace = namespace
		-- importedNamespace = env().lookupNamespace(pathName)
	}

context LambdaTypeCS 
def :  ast()  :ocl::LambdaType =
	ocl::LambdaType {
		name = name,
		contextType = ownedContextType.ast(),
		parameterType = ownedParameterType.ast(),
		resultType = ownedResultType.ast()   
	}

-- No idea about this
--context LibraryCS 
--		/*
--		 * TODO -> OclLibrary 
--		 */
-- def ast() : ocl::Library =


context ModelElementCS 
def : ast() : ocl::Element =
	pivot

context ModelElementRefCS 
def : ast() : ocl::Element  =
	element
	
--	context MultiplicityBoundsCS

--	context MultiplicityCS
	
--	context MultiplicityStringCS 
	
--	context NamedElementCS 

--	context NamespaceCS
	
-- FIXME what about the 'derived' qualifier ?
context OperationCS 
def : ast() : ocl::Operation =
	ocl::Operation {
		name = name,
		isStatic = qualifier->includes( 'static'),
		ownedTemplateSignature = ownedTemplateSignature.ast(),
		ownedParameter = ownedParameter.ast(),
		raisedException = ownedException.ast(),
		ownedAnnotation = ownedAnnotation.ast(),
		precondition = ownedPrecondition.ast(),
		postcondition = ownedPostcondition.ast(),
		bodyExpression = ownedBodyExpression.ast(),
		type = ownedType.ast(),
		owningType = if (qualifier->includes('definition'))
					 then null -- TODO Look for secondary type, create it if it doesn't exist, and say it's its owningType
					 else null -- FIXME return null, it will be added by owning class afterwards. BUT it will do the same even though if we have previously added it to a secondary type as well !!! 
					 endif				
	}

context PackageCS
def : ast() : ocl::Package =
	ocl::Package{				
		name = name,
		nsPrefix = nsPrefix,
		nsURI = nsURI,
		nestedPackage = ownedNestedPackage.ast(),
		ownedAnnotation = ownedAnnotation.ast(),
		ownedType = ownedType.ast()
	}

-- context PackageOwnerCS
	
context ParameterCS 
def : ast() : ocl::Parameter =
	ocl::Parameter {
		name = name,
		ownedAnnotation = ownedAnnotation.ast(),
		type =ownedType.ast()
	}
	
context PathElementCS
def : ast() : ocl::Element = 
	element 
	
-- context PathElementWithURICS

context PathNameCS 
def : ast() : ocl::Element =
	element
	
context PivotableElementCS
def : ast() : ocl::Element =
	pivot

context PrimitiveTypeRefCS
def : ast() : ocl::PrimitiveType =
	ocl::PrimitiveType {
		name = name
	}

context ReferenceCS
def : ast() : ocl::Property = 
	ocl::Property {
		name = name,
		isStatic = qualifier->includes('static'),
		isComposite = qualifier->includes('compososes'),
		isDerived = qualifier->includes('derived'),
		isReadOnly = qualifier->includes('readonly'),
		isResolveProxies = not qualifier->exists( x | x = '!resolve'),
		isTransient = qualifier->includes('transient'),
		isUnsettable = qualifier->includes('unsettable'),
		isVolatile = qualifier->includes('volatile'),
		keys = keys, -- No idea what is this for
		default = default, -- default vs defaultExpressions ?
		defaultExpression = if ownedDefaultExpression->notEmpty()
							then ownedDefaultExpression.ast()
							else null
							endif,
		ownedAnnotation = ownedAnnotation.ast(),
		type =	ownedType.ast(),
		opposite = if not (opposite = null)
		 		   then opposite
		 		   else ocl::Property {
								name = self.ast().owningType.name, -- FIXME hazard when having different types with same name => two properties with the same name
								implicit = true,
								isRequired = false,
								owningType = ownedType.ast()								
								-- FIXME how to statically define a collection of a dinamic Type  
								-- type = env().getCollectionType(ocl::CollectionKind::OrderedSet, thisType)
						}
					endif,
		owningType = if (qualifier->includes('definition'))
					 then null -- TODO Look for secondary type, create it if it doesn't exist, and say it's its owningType
					 else null -- FIXME return null, it will be added by owning class afterwards. BUT it will do the same even though if we have previously added it to a secondary type as well !!! 
					 endif
	}
	

-- context RootCS

context RootPackageCS
def :ast() : ocl::Root =
	ocl::Root {
		imports = ownedImport.ast(),
		nestedPackage = ownedNestedPackage.ast()
	}
 
context SpecificationCS
def : ast() : ocl::OpaqueExpression =
	ocl::OpaqueExpression  {
		language = 'OCL',
		_body =	Sequence(String){exprString}
	}
	
	
-- context StructuralFeatureCS
	
context TemplateBindingCS
def : ast() : ocl::TemplateBinding =
	ocl::TemplateBinding {
		parameterSubstitution = ownedParameterSubstitution.ast(),
		signature = owningTemplateBindableElement.ast().ownedTemplateSignature
	}
	
-- See TypeParameterCS
-- context TemplateParameterCS
context TemplateParameterSubstitutionCS
def : ast() : ocl::TemplateParameterSubstitution  = 
	ocl::TemplateParameterSubstitution {
		-- ownedActual. It looks like ownedActual is surplus
		actual = ownedActualParameter.ast(),
		formal = let elementPosition: Integer = owningTemplateBinding.ownedParameterSubstitution->indexOf(self) 
				 in owningTemplateBinding.owningTemplateBindableElement.ast().ownedTemplateSignature.ownedParameter->at(elementPosition)
	}
	
context TemplateSignatureCS
def : ast() : ocl::TemplateSignature =
	ocl::TemplateSignature {
		ownedParameter = ownedTemplateParameter.ast()
	}
	
context TuplePartCS
def : ast() : ocl::Property = 
	ocl::Property {
		name = name,
		type = ownedType.ast()
	}
	
context TupleTypeCS
def : ast() : ocl::TupleType =
	ocl::TupleType {
		name = name,
		ownedAttribute = ownedParts.ast()
	}
	
-- FIXME why distinct super/extends? Anyway, example of an growing pull
context TypeParameterCS 
def : ast() : ocl::TypeTemplateParameter =
	let parameteredElement = ocl::Class {
		name = name,
		superClass = ownedExtends.ast()->including
					 (ownedSuper.ast())
	}
	in	ocl::TypeTemplateParameter {
		ownedParameteredElement = parameteredElement,
		parameteredElement = parameteredElement
	}

context TypedRefCS
def : isMultiple() : Boolean = 
		multiplicity.getUpper() > 1
--def : ast(unique : Boolean, ordered : Boolean) : ocl::Type =
--	null -- FIXME
--	if not isMultiple()
--	then env().lookupType(pathName)
--	else 
--		if unique
--		then
--			if ordered
--			then env().lookupCollectionType('OrderedSet', self)
--			else env().lookupCollectionType('Set', self)
--			endif
--		else
--			if ordered
--			then env().lookupCollectionType('Sequence', self)
--			else env().lookupCollectionType('Bag', self)
--			endif
--		endif
--	endif

context TypedTypeRefCS
def : ast() : ocl::Type =
	if not isMultiple()
	then env().lookupType(self.pathName)
	else 
		let ordered = if oclContainer().oclIsKindOf(TypedElementCS)
					 	then oclContainer().oclAsType(TypedElementCS).qualifier->includes('ordered')
					 	else false
					 	endif,
			unique =  if  oclContainer().oclIsKindOf(TypedElementCS)
						then oclContainer().oclAsType(TypedElementCS).qualifier->includes('unique')
						else false
						endif
		in
			if unique
			then
				if ordered
				then env().lookupCollectionType('OrderedSet', self)
				else env().lookupCollectionType('Set', self)
				endif
			else
				if ordered
				then env().lookupCollectionType('Sequence', self)
				else env().lookupCollectionType('Bag', self)
				endif
			endif		
	endif



context WildcardTypeRefCS
def : ast() : ocl::UnspecifiedType =
	ocl::UnspecifiedType {
		superClass = extends.ast()
	}
	
context Environment
def : lookupLocal(name : String[?]) : NamedElementCS[?] = 
	null -- TODO
def : lookup(name : String[?]) : ocl::NamedElement[?] = 
	null -- TODO
def : lookupPathName(name : PathNameCS[?]) : ocl::NamedElement[?] =
	null -- TODO
def : lookupVariableDeclaration(name : String[?]) : ocl::VariableDeclaration[?] =
	null -- TODO
--def : lookupType(name : String[?]) : ocl::Type[?] = 
--	null -- TODO
def : lookupType(name : PathNameCS[?]) : ocl::Type[?] = 
	null -- TODO
def : lookupCollectionType(collectionKind : String[?], elementType : TypedRefCS[?]) : ocl::CollectionType[?] =
	null -- TODO

	
endpackage
